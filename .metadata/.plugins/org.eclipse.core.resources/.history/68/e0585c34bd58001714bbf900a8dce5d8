package algorithm;

import java.awt.Graphics;
import java.io.Serializable;
import java.util.ArrayList;


public class Edge implements Comparable<Edge>, Serializable{

	private Endpoint start, end;
	private Endpoint upper, lower;

	public int id;
	
	//Use these for comparisons in the Status tree
	public int current_X; 
	public int sweep_Y;
	
	public Edge(Endpoint start, Endpoint end, int id){
		this.start = start;
		this.end = end;
		setUpperAndLower();
		
		current_X = upper.getX();
		this.id = id;
	}
	
	public void updateXandSweep(int sweep_Y)
	{
		this.sweep_Y = sweep_Y;
		current_X = currentXCoord(sweep_Y);
	}
	

	
	
	public Endpoint getStart(){
		return start;
	}
	
	public Endpoint getEnd(){
		return end;
	}
	
	public void paintEdge(Graphics g){
		g.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
	}
	
	//Decide which is upper and lower in this segment AND add this segment as data to the upper and lower points
	private void setUpperAndLower(){
		if(start.getRealY()>end.getRealY() || start.getRealY() == end.getRealY() && start.getX()<end.getX()){
			upper = start;
			lower = end;
			start.addUpperTo(this);
			
			start.isUpper = true;
			
			end.isLower = true;
			end.addLowerTo(this);
		}
		else{
			upper = end;
			lower = start;
			end.addUpperTo(this);
			
			end.isUpper = true;
			
			start.isLower = true;
			start.addLowerTo(this);
		}
		current_X = upper.getX();
	}
	
	public Endpoint getUpper(){
		return upper;
	}
	
	public Endpoint getLower(){
		return lower;
	}
	
	public void changeUpper(Endpoint newUpper){
		upper = newUpper;
	}
	
	
	public int currentXCoord(int sweep_y){
		//If a vertical segment, it's x-choordinate is always the same.
		if(this.getUpper().getX()==this.getLower().getX() && (sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY())){
			return this.getLower().getX();
		}
		//If a horizontal segment: Set current x to upper.getX()
		else if(upper.getRealY() == lower.getRealY() && sweep_y == upper.getRealY()){//(sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY())){
			return upper.getX();
		}
		
		else if(sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY()){//We have a slope
			int deltaY = this.getUpper().getRealY()-this.getLower().getRealY();
			int deltaX = this.getUpper().getX()-this.getLower().getX();
			double k = (double)deltaY/(double)deltaX;
			
			//y = kx + m --> m = y - kx
			double m = this.getUpper().getRealY()-(k*this.getUpper().getX());//Använd kända värden på x och y.
			double x = (sweep_y - m)/k;
			x = Math.round(x);
			return (int) x;
		}
		
		else{
			System.out.println("sweep_y lies outside the segments endpoints."); //Just for fail checking
			return 2000;
		}
	}
	

	/**
	 * Compares the x-coordinate of this Edge to the one provided, at the current location of the sweep-line over that sweeps over the y-axis.
	 * @param: The Edge to compare this Edge to.
	 * @return: -1 ,0 or 1 if this Edge has a smaller x-coordinate value, equal or larger than the provided Edges' current x-coordinate.
	 * 
	 * NB! current_X and sweep_Y must be updated in the Edge object that is passed to this method beforehand!!
	 * 
	 * There are many cases, where the intersecting ones are most complex
	 * 		
	 * 		1. Adding a new segment, could be upper to one or many or be an intersection (intersection = upper to many when they arrive as new points)
	 * 		if(currentX < o.current_X) return -1
	 * 		else if(current_X > o.current_X) return 1
	 * 		else if(current_X == o.currentX)
	 * 			if(The segments are the same. Id or just overlapping + belonging?) return 0
	 * 			else if(this to left of o) return -1
	 * 			else if(this to right of o) return 1
	 * 			else do some trace
	 * 
	 * 
	 * 		2. Searching for a segment - same as above
	 * 
	 * 		3. Deleting a segment - same as above
	 * 			NB! A segment gets deleted due to a lower eventpoint is encountered or an intersection is handled. 
	 * 			
	 * 		Problems with current_X
	 * 			1. Using doubles in calculations might lead to rounding errors and misses. Should probably use linear algebra here. Compare one current x with an entire edge.
	 * 			2. The best way would be to use the current x only in the segment that is input to the tree, not in the segments that lies within the tree. This way we avoid having to update the entire tree.
	 * 			
	 * 			Example:
	 * 				1. Adding a new segment:
	 * 					newSeg.updateX-coord();
	 * 					status.add(newSeg); <----------Compare to now compares like this: in an edge e: if(this isToRightOf(newSeg.current_X())) return -1. Easier to find a segment then too!
	 * 	
	 * 		
	 * 		
	 * 
	 * 
	 * 
	 * Case 1: x1 < x2 -> return -1
	 * 		Case 2: x1 > x2 -> return 1
	 * 		Case 3: x1 == x2
	 * 					3.1 if they are uppers to many
	 * 					or intersection -> compare their lowers and return -1, 0 or 1
	 * 					3.2 else if they are lower point 
	 * 							-> This should not happen because all edges should have been erased before
	 * 							-> p might be a lower and an upper but this is an else if, meaning that the upper-if above will take it instead
	 * 
	 * 
	 * 		All cases ()
	 * 				- uppers to many
	 * 				- upper to many and an intersection
	 * 				- upper to one and an intersection
	 * 				- etc... skip these for now
	 * 
	 *  NB! current_X of this edge and the one we compare to need to be updated before comparing.
	 *  How to avoid unnecessary updates?
	 */				
	@Override
	public int compareTo(Edge o) {
		//The absolutely most simple check first. Added 2017-06-18.
		if(o.current_X < current_X)
		{
			return 1;
		}
		else if (o.current_X > current_X)
		{
			return -1;
		}
		
		if(comparePointToEdge(o.current_X, o.sweep_Y) < 0){
			//System.out.println("Segment o is to the left(?), return -1");
			return -1;
		}
		else if(comparePointToEdge(o.current_X, o.sweep_Y) > 0) {
			//System.out.println("Segment o is to the right(?), return 1");
			return 1;
		}
		else
		{
			if((lower.isEqualTo(o.lower)) && (upper.isEqualTo(o.getUpper())))// && (upper.getBelonging() == o.upper.getBelonging())) //Need more checks? Id?`IDs must then follow along each segments wherever they may reside.
			{
				return 0;
			}

			else if(upper.upperToArrayContains(o))
			{
				//Compare their lower endpoints
				if(comparePointToEdge(o.getLower().getX(), o.getLower().getRealY()) < 0) {
					//System.out.println("Segment o is to the left(?), return -1");
					return -1;
				}
				else if(comparePointToEdge(o.getLower().getX(), o.getLower().getRealY()) > 0) {
					//System.out.println("Segment o is to the right(?), return 1");
					return 1;
				}
				System.out.println("Edge.compareTo() failed (1)");
				return 0;
			}
			//They share the same lower but are different segments
			else if(lower.lowerToArrayContains(o))
			{
				//System.out.println("Segment o has the same lower as another segment");
				
				// -> compare their upper endpoints
				if(comparePointToEdge(o.getUpper().getX(), o.getUpper().getRealY()) < 0) {
					//System.out.println("o:s upper is to the left of the other segment, return -1");
					return -1;
				}
				else if(comparePointToEdge(o.getUpper().getX(), o.getUpper().getRealY()) > 0) {
					//System.out.println("o:s upper is to the right of the other segment, return 1");
					return 1;
				}
				System.out.println("Edge.compareTo() failed (2)");
				return 0;
			}
			else
			{
				//The current point of segment o is on the line of THIS segment
				//It is not the same segment
				//It is not the upper to THIS segment
				//It is the LOWER to this segment
				
				//Should update current x and sweep y of THIS segment here. Still just a test so don't need it. (Should be updated outside anyway.)
				int comparison = o.comparePointToEdge(current_X, sweep_Y);
				if(comparison > 0) return -1;
				else if(comparison < 0) return 1;
				System.out.println("Edge.compareTo() FAILED REALLY BAAAAAD (3)");
				return 0;
			}
		}
	}
	
	/**
	 * Created 2017-06-03
	 * Purpose: Compare a point to a segment to see which side it lies on
	 * Needs: unit test
	 * @param p
	 * @return
	 */
	private int comparePointToEdge(int p_x, int p_y) { //Risk with current x: it has to be calculated using doubles and then cast to int. Might miss intersections... but, intersections might already be caught??
		int x1 = upper.getX();
		int y1 = upper.getRealY();
		
		int x2 = lower.getX();
		int y2 = lower.getRealY();
		
		double d = (p_x - x1) * (y2 - y1) - (p_y - y1) * (x2 - x1);
		
		if(d < 0) return -1;
		else if(d > 0) return 1;
		else return 0;		
	}
	
	
	/*Används ej mer.
	 * Returnerar 	-1 om denna edge pekar åt vänster i förhållande till Edge e.
	 * 				+1 om denna edge pekar åt höger
	 * 				0 om de är samma
	 */
	public int specialCompareTo(Edge e, int sweep_y){
		if(currentXCoord(sweep_y) < e.currentXCoord(sweep_y) || currentXCoord(sweep_y) == e.currentXCoord(sweep_y) && compareSides(sweep_y-1, e)==-1){//Check om detta redan är en lower???
			//Kolla riktning direkt under sweepline!!! Hur görs deta bäst?
			//Använd upper och lower som line. Kolla vilken sida this.lower ligger på. typ.
			return -1;
		}
		else if(currentXCoord(sweep_y)>e.currentXCoord(sweep_y) || currentXCoord(sweep_y)==e.currentXCoord(sweep_y) && compareSides(sweep_y-1, e)==1){
			return 1;
		}
		else if(currentXCoord(sweep_y)==e.currentXCoord(sweep_y)&&compareSides(sweep_y, e)==0){//Problematiskt att använda lower här. Blir fel vid korsade linjer.
			return 0;
		}
		System.out.println("Lacking if-statement in specialCompareTo in Edge.");
		return 0;
	}
	
	//Används bara då två segment har punkter i samma x-coord
	//Nu beräknar denna vilka om ett segment ligger till vänster om ett annat precis under sveplinjen
	public int compareSides(int sweep_y, Edge e){//Tidigare tog denna en endpoint som var e.getLower()
		double x1 = currentXCoord(sweep_y);
		double x2 = e.currentXCoord(sweep_y);
		
		
		//Fullösning. Kan funka eftersom inget segment som har lowerpoint i nuvarande p ska sökas igenom. Förhoppningsvis redan borttaget.
		if(x1==x2){
			return 0;
		}
		else if(x1 < x2){
			return -1;
		}
		
		else if(x1>x2){
			return 1;
		}
		
		//Determinant stuff
		/*int det = (lower.getX()-upper.getX())*(p.getRealY()-upper.getRealY()) - (lower.getRealY()-upper.getRealY())*(p.getX()-upper.getX());
		if(det<0){
			return 1;
		}
		else if(det>0){
			return -1;
		}
		
		return 0;*/
		System.out.println("Compare sides i Edge returnerar fel.");
		return 0;
	}
	
	//Ändra i search: Om current x är lika men uppers och lowers inte är det. Då har vi detta specialfall!
	//Denna används för att avgöra vilken sida av ett annat segment ett segment ska sättas in i i statusen.
		public int isToRightOrLeftOf(Edge segment){
			//Determinant stuff
			int det1 = (segment.getLower().getX()-segment.getUpper().getX())*(getUpper().getRealY()-segment.getUpper().getRealY()) - (segment.getLower().getRealY()-segment.getUpper().getRealY())*(getUpper().getX()-segment.getUpper().getX());
			int det2 = (segment.getLower().getX()-segment.getUpper().getX())*(getLower().getRealY()-segment.getUpper().getRealY()) - (segment.getLower().getRealY()-segment.getUpper().getRealY())*(getLower().getX()-segment.getUpper().getX());
			if(det1<0 || det1==0 && det2<0){//Be careful with the grouping here. This mght be wrong.
				return -1;
			}
			else if(det1>0 || det1 == 0 && det2>0){//Kolla både upper och lower om upper skulle vara samma för båda
				return 1;
			}
					
			else return 0;//They are on a line(Might not work if there is to different segments on a line.)
		}
		
		
		//Denna metod funkade 27/1
		//Returnerar null om intersection ligger utanför segmentens endpoints
		//Testa med vertikala och horisontella linjer
		public Endpoint isCrossingWith(Edge segment){
			System.out.println("Inne i metoden.");
			if(upper.getX()!=lower.getX() && segment.getUpper().getX()!=segment.getLower().getX()){//Avoid division by zero. Test this case!
				
				System.out.println("Linjerna lutar!");//Fail!!! Det gör de inte alls! Behöver ett test mot horisontell linje
				
				double k1 = (upper.getRealY()-lower.getRealY())/(upper.getX()-lower.getX());
				double k2 = (segment.getUpper().getRealY()-segment.getLower().getRealY())/(segment.getUpper().getX()-segment.getLower().getX());
				
				double m1 = upper.getRealY()-(k1*upper.getX());//Använd kända värden på x och y.
				double m2 = segment.getUpper().getRealY()-(k2*segment.getUpper().getX());//Använd kända värden på x och y.
				
				double x = (m1-m2)/(k2-k1);//Correct? Om det är en intersection. Oops. Division med 0 här om det är parallella linjer! Fixit!
				double y1 = k1*x+m1;
				double y2 = k2*x+m2;
				
				//Hittar inte intersection då ena linjen är horisontell
				if(y1==y2 && y1<upper.getRealY() && y1>lower.getRealY() && y1<segment.getUpper().getRealY() && y1>segment.getLower().getRealY()){
					System.out.println("The method is working. We have an intersection at:" + x +", "+ y1);
					Endpoint intersection = new Endpoint((int)x, (int)y1);
					System.out.println("Hej och hå!");
					return intersection;
				}
				else{
					System.out.println("Går den in i else?");
					
				}
			}
			else System.out.println("Division by zero in method isCrossingWith() in Edge."); return null;
		}
		
		
		 /**
		0002   * Computes the intersection between two segments. 
		0003   * @param x1 Starting point of Segment 1
		0004   * @param y1 Starting point of Segment 1
		0005   * @param x2 Ending point of Segment 1
		0006   * @param y2 Ending point of Segment 1
		0007   * @param x3 Starting point of Segment 2
		0008   * @param y3 Starting point of Segment 2
		0009   * @param x4 Ending point of Segment 2
		0010   * @param y4 Ending point of Segment 2
		0011   * @return Point where the segments intersect, or null if they don't
		0012   */
		
		
		//http://www.ahristov.com/tutorial/geometry-games/intersection-segments.html
		//This method is for spotting an intersection between two segments. This intersection
		//shall later be inserted as a new eventPoint in the queue
		
		//2016-04-06: This seems to be in use but not handling vertical segments like it should.
		//Test performed:
		public Endpoint doIntersect(Edge segment) {
				    int x1 = upper.getX();
				    //int y1 = upper.getRealY();
				    int y1 = upper.getY();//Måste använda getY() och inte realY() här.
				    int x2 = lower.getX();
				    //int y2 = lower.getRealY();
				    int y2 = lower.getY();
				    
				    int x3 = segment.getUpper().getX();
				    //int y3 = segment.getUpper().getRealY();
				    int y3 = segment.getUpper().getY();
				    int x4 = segment.getLower().getX();
				    //int y4 = segment.getLower().getRealY();
				    int y4 = segment.getLower().getY();
			
			
					int d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4); //Denominator determinant for point calculation
				    if (d == 0) return null;//Lines are parallell
				    
				    //Point calculation
				    int xi = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;
				    int yi = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;
				    
				  //Added 2016-04-06: Check if any of the lines are vertical
			        if(x1 == x2 || x3 == x4){
			            //2016-04-06: Check if the intersection point lies outside any of the segment in the y direction
			            if(yi < Math.min(y1, y2) || yi > Math.max(y1, y2)) return null;
			            if(yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) return null;
			        }
				    
				    //Check if intersection lies outside the segments endpoints
				    Endpoint p = new Endpoint(xi,yi);
				    if (xi < Math.min(x1,x2) || xi > Math.max(x1,x2)) return null;
				    if (xi < Math.min(x3,x4) || xi > Math.max(x3,x4)) return null;
				    return p;
				  }
		
		
		//http://www.ahristov.com/tutorial/geometry-games/intersection-segments.html
		//This method is for spotting an intersection between two segments. This intersection
		//shall later be inserted as a new eventPoint in the queue
		public Endpoint intersectionOf(int x1,int y1,int x2,int y2, int x3, int y3, int x4,int y4) {
			int d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4); //Denominator determinant for point calculation
			if (d == 0) return null;//Lines are parallell

			//Point calculation
			int xi = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;
			int yi = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;

			//Check if intersection lies outside the segments endpoints
			Endpoint p = new Endpoint(xi,yi);
			if (xi < Math.min(x1,x2) || xi > Math.max(x1,x2)) return null;
			if (xi < Math.min(x3,x4) || xi > Math.max(x3,x4)) return null;
			return p;
		}
		
		

}
