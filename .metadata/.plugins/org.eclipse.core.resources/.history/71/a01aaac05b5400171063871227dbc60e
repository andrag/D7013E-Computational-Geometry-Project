package algorithm;

import java.util.ArrayList;
import java.util.logging.Logger;
import datastructures.*;


public class CollisionDetection extends ArrayList<Endpoint>{

	private static final long serialVersionUID = 1L;
	private AVLTree eventQueue;
	private StatusTreeSet status;
	private ArrayList<Endpoint> allIntersections;

	private static int edgeID = 0;//For keeping track of all the edges
	private boolean intersecting = false;

	public CollisionDetection(Endpoint startpoint1, Endpoint startpoint2){
		//Make an eventqueue BBST
		eventQueue = new AVLTree();
		Endpoint current = startpoint1;
		allIntersections = new ArrayList<Endpoint>();

		while(current.getNextSeg().getEnd()!=startpoint1){
			eventQueue.insert(current);	 
			current = current.getNextSeg().getEnd();
		}
		eventQueue.insert(current);
		current = startpoint2;
		while(current.getNextSeg().getEnd()!=startpoint2){
			eventQueue.insert(current);
			current = current.getNextSeg().getEnd();
		}
		eventQueue.insert(current);


		status = new StatusTreeSet();
		while(eventQueue.root.left!=null || eventQueue.root.right!=null){//!eventQueue.isEmpty()
			Endpoint next = eventQueue.findLargest(eventQueue.root);
			eventQueue.traverseInOrder();
			eventQueue.delete(next);
			handleEventPoint(next);
		}
	}

	
	public void handleEventPoint(Endpoint p){
		
		if(p.isLower){
			System.out.println("===============================Handle a lower eventpoint=============================");
			
			
			int sweep_Y = p.getRealY();
			status.updateAll(sweep_Y);

			//Delete all segments that has a lower point in p
			for(Edge e : p.getLowerTo()){
				status.remove(e);
				e.getUpper().isUpperTo.remove(e);
			}
			p.getLowerTo().clear();
			status.traverseStatus();
		}

		if(p.isUpper() && !p.isIntersection){
			System.out.println("/n================================Handle an upper event point===================================/n/n");

			int sweep_Y = p.getRealY();
			status.updateAll(sweep_Y);
			
			
			if(p.getUpperTo().size()>1){//Point p is an upper point to two segments. Add both.
				for(Edge e : p.getUpperTo()){
					e.updateXandSweep(sweep_Y);
					status.add(e);

					/*if(p.getBelonging() != e.getLower().getBelonging()){ //Check if they belong to the same polygon. No need, already checked in intersection points.
						intersecting = true;
					}
					else System.out.println("No collisiion between this uppers segments. This case should only appear in the top point of a polygon if it is really simple :)");
				*/}

				//Find out which segment is leftmost resp rightmost
				Edge left = p.findLeftmost();//Replaced by leftmost and rightmost inside Endpoints class
				Edge right = p.findRightmost();

				//Find their neighbours in the status
				Edge leftNeighbour = status.lower(left);
				Edge rightNeighbour = status.higher(right);

				//Check if the newly inserted segments intersect with their neighbours
				findNewEvent(leftNeighbour, rightNeighbour, p, false);
			}
			else {
				//This is an upper point to just one segment
				p.getUpperTo().get(0).updateXandSweep(sweep_Y);
				
				status.add(p.getUpperTo().get(0));

				//Find left and right neighbours of the new segment
				Edge leftNeighbour = status.lower(p.getUpperTo().get(0));
				Edge rightNeighbour = status.higher(p.getUpperTo().get(0));

				//Check if the new segment intersect a neighbour in the status
				findNewEvent(leftNeighbour, rightNeighbour, p, false);
			}
		}

		if(p.isIntersection){

			System.out.println("=====================Handling an intersection eventpoint====================\n");

			intersecting = true;
			handleIntersectingSegments(p);
			p.isUpper = true;

			Edge left = p.findLeftmost();
			Edge right = p.findRightmost();

			Edge leftNeighbour = status.lower(left);
			Edge rightNeighbour = status.higher(right);

			findNewEvent(leftNeighbour, rightNeighbour, p, false);
		}


		if(intersecting == true){//Feltänk här. Måste bygga på antal element som upper är upper till.  <------------Fortfarande??
			System.out.println("p är en intersection point, är nu upper till mer än ett segment. Lägg till p i intersection-arrayen.");
			allIntersections.add(p);//This might already be added in findNewEvent!!!
			intersecting = false;
		}
		System.out.println("\n====================================Slut på handleEventPoint.==========================================");
	}




	public ArrayList<Endpoint> getIntersections(){
		return allIntersections;
	}


	//Är det ens nödvändigt att beskära elementen??

	/**
	 * Performs a cutting of the parts of the segments that lie above p
	 * Deletes the old segments and insert the new shorter ones into the status. This reorders them in the status tree.
	 * @param p An intersection point between two(?) segments 
	 */
	private void handleIntersectingSegments(Endpoint p){
		//1. Get the segments that are involved in the intersection (Only two are possible in this implementation, otherwise they cross themselves = not ok)
		Edge tempSeg1 = p.getUpperTo().get(0);
		int id1 = tempSeg1.id;
		
		Edge tempSeg2 = p.getUpperTo().get(1);
		int id2 = tempSeg2.id;
		
		//2. Delete them from the status.... How to do this when there is an intersection??? The point will lie on the line but they will be reoredered under the point so the search will not find it.
		//Solution - temporarily set the current_x of the segments to their FORMER value.Wait with updating til after this deleting is done!
		System.out.println("handleIntersection removes uncropped segments: " + tempSeg1.id + " and " + tempSeg2.id);
		System.out.println("Status before removal");
		status.traverseStatus();
		
		tempSeg1.updateXandSweep(tempSeg1.getUpper().getRealY());
		tempSeg2.updateXandSweep(tempSeg2.getUpper().getRealY());
		
		status.remove(tempSeg1);
		status.remove(tempSeg2); //<----------------------------------------THIS ONE FAILS TO REMOVE SEGMENT 5 (2017-06-18)
		
		System.out.println("Status after removal");
		status.traverseStatus();
		
		//3. Remove their references at their former upper
		tempSeg1.getUpper().isUpperTo.remove(tempSeg1);
		tempSeg2.getUpper().isUpperTo.remove(tempSeg2);
		
		//4. Set the intersecting point as being their new upper
		tempSeg1.changeUpper(p);
		tempSeg2.changeUpper(p);
		
		

		//3. Remove the references to them at their lower points - This should not be needed if we change the old segments instead of making new ones.
		/*Endpoint tempLower = tempSeg1.getLower();
		int index = -1;
		for(Edge segment : tempLower.getLowerTo()){
			if(segment.compareTo(tempSeg1)==0){
				index = tempLower.getLowerTo().indexOf(segment);
			}
		}
		if(index != -1){
			tempLower.getLowerTo().remove(index);
		}
		tempLower = tempSeg2.getLower();
		index = -1;
		for(Edge segment : tempLower.getLowerTo()){
			if(segment.compareTo(tempSeg2)==0){
				index = tempLower.getLowerTo().indexOf(segment);
			}
		}
		if(index != -1){
			tempLower.getLowerTo().remove(index);
		}*/

		//4. Make the Edge objects point their upper to point p, the intersection
		

		//5. Point p to be upper to the new shorter segments. Do we need to do something with start and end points in the Edge object?
		/*p.clearSegmentsInUpperTo();
		p.addUpperTo(tempSeg1);//This should be done in the changeUpper of the segment
		p.addUpperTo(tempSeg2);*/

		//6. Add the shortened segments to the lower points isLowerTo-arrays
		/*tempSeg1.getLower().addLowerTo(tempSeg1);
		tempSeg2.getLower().addLowerTo(tempSeg2);*/
		
		//5. Update the status such that an add will be just like adding a new upper point of two segments
		int sweep_Y = p.getRealY();
		status.updateAll(sweep_Y); //<------------- Update sweep_y of tempSeg1 and tempSeg2  as well! Forgot!
		
		tempSeg1.updateXandSweep(sweep_Y);
		tempSeg2.updateXandSweep(sweep_Y);

		//6. Insert the new modified segments into the status again
		status.add(tempSeg1);
		status.add(tempSeg2);

		//Print the changes to the intersecting segments
		System.out.println("===========================================\nAn intersection as been handled. Traverse the status tree.\n______________________________________________");
		status.traverseStatus();
	}

	/*
	 * Egentligen ska denna ta en leftneighbour och en right neighbour samt p som jämför left och right med sitt segment.
	 * Om p är upper till massa segment --> gör check för leftmost och rightmst här?
	 */

	public void findNewEvent(Edge leftNeighbour, Edge rightNeighbour, Endpoint p, boolean lower){//Borde köra point här istället så kan man kolla o den ska leta upp leftmost och rightmost.
		Endpoint crossing;
		if(!lower){//Do a check here if we are handling a lower or an upper.... What if it's both? Good question. //This is never used

			//Check if left neighbour is null
			if(leftNeighbour==null)
				System.out.println("There is no left neighbour.");

			//Check if the segment cross its left neighbour
			else{
				if(p.getUpperTo().size()>1){

					//Check left segment againts left neighbour
					crossing = p.leftmost.doIntersect(leftNeighbour);
					if(crossing == null){
						System.out.println("The left segment doesn't intersect with its left neighbour.");
					}
					//Check so the crossing is not in the same lower.
					else if(!(leftNeighbour.getLower().compareTo(p.leftmost.getLower())==0)){ //if(crossing.compareTo(left.getUpper())!=0 && crossing.compareTo(p.leftmost.getUpper())!=0){//To avoid a loop where the intersection will discover itself again and again.

						//The segments intersect, create a new eventpoint if they belong to different polygons
						if(leftNeighbour.getLower().getBelonging() != p.leftmost.getLower().getBelonging()){
							System.out.println("The left segment cross its left neighbour, create new event point.");
							System.out.println("They intersect at: ("+crossing.getX()+", "+crossing.getRealY()+")");
							Endpoint intersection = new Endpoint(crossing.getX(), crossing.getY());
							intersection.isIntersection = true;
							intersection.setBelonging(p.getBelonging());

							//Send the involved segments with the intersection
							intersection.getUpperTo().add(leftNeighbour);
							intersection.getUpperTo().add(p.leftmost);
							eventQueue.insert(intersection);
							//allIntersections.add(intersection);//Maybe not needed here. This is doubled in the last statement in handleEventPoitn. Doesn't matter.
						}		
					}
					else System.out.println("The left segment intersect with its left neighbour in both their lower points");
				}
				else if(p.getUpperTo().size()==1){
					//Check the only segment against its left neighbour
					crossing = p.getUpperTo().get(0).doIntersect(leftNeighbour);
					if(crossing == null){
						System.out.println("The segment doesn't intersect with its left neighbour.");
					}
					//Check that the crossing isn't a crossing between two lowers.
					else if(p.getUpperTo().get(0).getLower().compareTo(leftNeighbour.getLower())!=0 && p.getBelonging() != leftNeighbour.getLower().getBelonging()){//This should be ok. Only 1 element in isUpperTo --> this is not sprung from an intersection point
						System.out.println("The segment cross its left neighbour, create new event point.");
						//The segments intersect, create a new eventpoint

						//Check if the line ends on its neighbour or totally cross it. If it ends on the neighbour, just create
						//a new upper would suffice, instead of an intersection. No swapping necessary.
						if(p.getUpperTo().get(0).getLower() == crossing){
							//Create a new upper. Set isUpperTo till en mindre version av det gamla. Borde funka.

							//Har inte gjort något med denna. Bara speciella fall. Kanske inte ens behövs.
						}

						Endpoint intersection = new Endpoint(crossing.getX(), crossing.getY());
						//intersection.isUpper = true;
						intersection.isIntersection = true;
						intersection.setBelonging(p.getBelonging());//Kanske är detta fel?

						//Send the involved segments with the intersection
						intersection.getUpperTo().add(leftNeighbour);
						intersection.getUpperTo().add(p.getUpperTo().get(0));
						eventQueue.insert(intersection);
						//Also set p to isUpper?? Annars gör om alla checkar att kolla om UpperTo-arrayen är tom eller inte.

					}


					else if(p.getUpperTo().get(0).getLower().compareTo(leftNeighbour.getLower())!=0 && p.getBelonging() == leftNeighbour.getLower().getBelonging()){
						System.out.println("Jaja segmentet korsar sin vänstra granne men de tillhör samma polygon.");
						System.out.println("Den vänstra grannen är segmentet: ("+leftNeighbour.getUpper().getX()+", "+leftNeighbour.getUpper().getRealY()+"), ("+leftNeighbour.getLower().getX()+", "+leftNeighbour.getLower().getRealY()+")");
					}

					else System.out.println("The segment intersect with its left neighbour in both their lower points. Do something about this special case if needed.");

				}
			}

			//Check if right neighbour is null
			if(rightNeighbour==null)
				System.out.println("There is no right neighbour.");

			//Check if the segment cross its right neighbour
			else{
				if(p.getUpperTo().size()>1){

					//Check right segment againts right neighbour
					crossing = p.rightmost.doIntersect(rightNeighbour);
					if(crossing == null){
						System.out.println("The right segment doesn't intersect with its right neighbour.");
					}
					//Check that crossing isn't a crossing between two lowers and that they belong to different polygons
					else if(p.rightmost.getLower().compareTo(rightNeighbour.getLower())!=0 && p.rightmost.getLower().getBelonging() != rightNeighbour.getLower().getBelonging()){// if(crossing.compareTo(right.getUpper())==0 && crossing.compareTo(p.rightmost.getUpper())!=0){
						System.out.println("The right segment cross its right neighbour, create new event point.");
						System.out.println("They intersect at: ("+crossing.getX()+", "+crossing.getRealY()+")");
						//The segments intersect, create a new eventpoint
						Endpoint intersection = new Endpoint(crossing.getX(), crossing.getY());
						//intersection.isUpper = true;
						intersection.isIntersection = true;
						intersection.setBelonging(p.getBelonging());

						//Send the involved segments with the intersection
						intersection.getUpperTo().add(rightNeighbour);
						intersection.getUpperTo().add(p.rightmost);
						eventQueue.insert(intersection);
					}
					else System.out.println("The right segment intersect with its right neighbour in both their lower points.");
				}
				else if(p.getUpperTo().size()==1){
					//Check the only segment against its right neighbour
					crossing = p.getUpperTo().get(0).doIntersect(rightNeighbour);
					if(crossing == null){
						System.out.println("The segment doesn't intersect with its right neighbour.");
					}
					else if(p.getUpperTo().get(0).getLower().compareTo(rightNeighbour.getLower())!=0 && p.getBelonging() != rightNeighbour.getLower().getBelonging()){//Index out of bounds exception! Crossing har inget i sin array??
						System.out.println("The segment cross its right neighbour, create new event point.");
						//The segments intersect, create a new eventpoint
						Endpoint intersection = new Endpoint(crossing.getX(), crossing.getY());
						//intersection.isUpper = true;
						intersection.isIntersection = true;
						intersection.setBelonging(p.getBelonging());

						//Send the involved segments with the intersection
						intersection.getUpperTo().add(rightNeighbour);
						intersection.getUpperTo().add(p.getUpperTo().get(0));
						eventQueue.insert(intersection);
					}
					else System.out.println("The segment intersect with its right neighbour in both their lower points.");
				}
			}
		}
		if(lower){ //This code is never run I think as of 2015-05-12
			//This code shouldn't be run when we deal with closed polygons. There will always be an upper directly after the lower.


			if(leftNeighbour!=null && rightNeighbour !=null &&! p.isUpper){//Added a check against upper coinciding with lower. Then should not check the neighbours, already done against the uppers segment(s).
				//Check left and right neighbours against eachother
				crossing = leftNeighbour.doIntersect(rightNeighbour);
				if(crossing==null){
					System.out.println("A lower endpoint should now have been deleted. It's two neighbours doesn't intersect.");
				}
				else if(leftNeighbour.getLower().compareTo(rightNeighbour.getLower())!=0){//A check here against lower being the same as an intersection? No. Should be caught in the first findIntersectingSegments. I guess. This executes the lowers segment. I think.
					System.out.println("A lower endpoint has probably been deleted. It's neighbours intersect.");
					Endpoint intersection = new Endpoint(crossing.getX(), crossing.getY());
					//intersection.isUpper = true;
					intersection.isIntersection = true;
					intersection.setBelonging(p.getBelonging());

					//Send the involved segments with the intersection
					p.getUpperTo().add(leftNeighbour);
					p.getUpperTo().add(rightNeighbour);
					eventQueue.insert(intersection);
				}
				else System.out.println("The lowers neighbours cross and their lower points coincide. No need for a new intersection point.");
			}
			else{
				System.out.println("A lower endpoint has probably been deleted. At least one of its neighbours is null. No new intersections can be found here.");
			}
		}
	}

	//Test för att se om allt funkar.

	/*This function was used to handle the last event point. Wait with this for now (2017-06-03)
	private void handleLastPoint(Endpoint p){
		boolean intersection = false;
		if(p.isUpper){
			System.out.println("Sista eventpointen är en upper. Något är fel.");
		}
		if(p.isLower){
			System.out.println("Sista eventpointen är en lower, precis som det ska vara.");
			ArrayList<Edge> segments = new ArrayList<Edge>();
			status.deleteWithLower(p, segments);
			if(segments.size()>1){
				for(int i = 1;i<segments.size();i++){
					if(segments.get(i).getUpper().getBelonging()!=segments.get(i-1).getUpper().getBelonging()){
						intersection = true;
					}
				}
			}
		}
	}*/


	/*public int getSweepY(){
		return sweep_y;
	}*/

	public static int incrementAndGetEdgeID(){
		edgeID++;
		return edgeID;
	}
}
