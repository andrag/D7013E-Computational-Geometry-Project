package algorithm;

import java.awt.Color;
import java.awt.Graphics;
import java.io.Serializable;
import java.util.ArrayList;

//import datastructures.Edge;

public class Edge implements Comparable<Edge>, Serializable{//Last one only needed for storing?

	private Endpoint start, end;
	private Endpoint upper, lower;
	//Added 2017-04-09
	private int id; //Use this to find the correct edge in the status tree
	public int current_X; //Use this for comparisons in the Status tree
	public int sweep_Y;
	
	
	public Edge(Endpoint start, Endpoint end, int id){ //Lägg till id här
		this.start = start;
		this.end = end;
		setUpperAndLower();
		
		current_X = upper.getX();
		this.id = id;
	}
	
	
	public Endpoint getStart(){
		return start;
	}
	
	public Endpoint getEnd(){
		return end;
	}
	
	public void paintEdge(Graphics g){
		g.drawLine(start.getX(), start.getY(), end.getX(), end.getY());
	}
	
	//Decide which is upper and lower in this segment AND add this segment as data to the upper and lower points
	private void setUpperAndLower(){
		if(start.getRealY()>end.getRealY() || start.getRealY() == end.getRealY() && start.getX()<end.getX()){
			/*start.setUpper();
			end.setLower();
			start.setSegment(this);
			end.setSegment(this);*/
			
			//start.setPointUpperTo(this);
			//end.setPointIsLowerTo(this);
			upper = start;
			lower = end;
			start.addUpperTo(this);
			start.isUpper = true;
			end.isLower = true;
			end.setLowerTo(this);
			
			//end.addLowerTo(this);
		}
		else{
			/*start.setLower();
			end.setUpper();
			end.setSegment(this);
			start.setSegment(this);*/
			upper = end;
			lower = start;
			end.addUpperTo(this);
			end.isUpper = true;
			start.isLower = true;
			start.setLowerTo(this);
			//start.addLowerTo(this);
		}
	}
	
	public Endpoint getUpper(){
		return upper;
	}
	
	public Endpoint getLower(){
		return lower;
	}
	
	public void changeUpper(Endpoint newUpper){
		upper = newUpper;
	}
	
	/**
	 * Get the x-coordinate of this line segment from the current y-coordinate of the sweep line
	 * @param sweep_y
	 * @return current x-coordinate
	 */
	public void updateXCoord(int sweep_y){
		current_X = currentXCoord(sweep_y);
		
	}
	
	//Denna returnerar fel så in i bomben!! Används ej mer. <--------------------------------------------TA REDA PÅ VILKEN SOM SKA ANVÄNDAS!
	//Ska ha korrekt matte! Bör jag lägga till constraints för endpointsen i segmenten???
	
	
	/* Input (124, 325), (22, 277) ger 0 för sweep 124.
	 * Input (124, 325), (206, 108) ger 124 för sweep 124.
	 */
	
	/*Test with returning double
	 * 
	 */
	public int currentXCoord(int sweep_y){
		//System.out.println("Inne i currentXCoord");
		//If a vertical segment, it's x-choordinate is always the same.
		if(this.getUpper().getX()==this.getLower().getX() && (sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY())){
			//System.out.println("Segmentet är vertikalt.");
			//Lägg till en if y == this.getUpper().getY()){ //För att hålla inom ramarna. Om det behövs. Samma i else nedan. Behövs inte för sweep line.
			return this.getLower().getX();//Any x will do. They are the same. This also skips dividing by zero in y = kx+m below.
		}
		//If a horizontal segment: Try setting current x to upper.getX()
		else if(upper.getRealY() == lower.getRealY() && (sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY())){
			//System.out.println("Segmentet är horisontellt.");
			return upper.getX();
		}
		
		else if(sweep_y <= upper.getRealY() && sweep_y >= lower.getRealY()){//We have a slope
			/*System.out.println("Segmentet lutar.");
			System.out.println("Upper: ("+this.getUpper().getX()+","+this.getUpper().getRealY()+")");
			System.out.println("Lower: ("+this.getLower().getX()+", "+this.getLower().getRealY()+")");
			System.out.println("DeltaY = "+ (this.getUpper().getRealY() - this.getLower().getRealY()));
			System.out.println("DeltaX = "+ (this.getUpper().getX()-this.getLower().getX()));*/
			int deltaY = this.getUpper().getRealY()-this.getLower().getRealY();
			int deltaX = this.getUpper().getX()-this.getLower().getX();
			double k = (double)deltaY/(double)deltaX;
			//System.out.println("k = "+k);
			
			//y = kx + m --> m = y - kx
			double m = this.getUpper().getRealY()-(k*this.getUpper().getX());//Använd kända värden på x och y.
			//System.out.println("m = "+m);
			
			//y = kx + m --> x = (y-m)/k
			double x = (sweep_y - m)/k;
			//System.out.println("x = "+x);
			x = Math.round(x);
			return (int) x;
		}
		
		else{
			System.out.println("sweep_y lies outside the segments endpoints.");
			return 2000;
		}
	}
	//Används ej mer.
	//Kollar endast om ett segment har lägre x-värde än ett annat då y = sweep_y
	//Har de samma x-värde ska en annan funktion rapportera intersection
	public boolean isSmallerThan(Edge segment, int sweep_y){
		if(currentXCoord(sweep_y) < segment.currentXCoord(sweep_y)){//If they are the same, they will be prioritized according to direction.
			return true;
		}
		else return false;
	}

	/**
	 * Compares the x-coordinate of this Edge to the one provided, at the current location of the sweep-line over that sweeps over the y-axis.
	 * @param: The Edge to compare this Edge to.
	 * @return: -1 ,0 or 1 if this Edge has a smaller x-coordinate value, equal or larger than the provided Edges' current x-coordinate.
	 * 
	 * There are many cases, where the intersecting ones are most complex
	 * 		
	 * 		1. Adding a new segment, could be upper to one or many or be an intersection (intersection = upper to many when they arrive as new points)
	 * 		if(currentX < o.current_X) return -1
	 * 		else if(current_X > o.current_X) return 1
	 * 		else if(current_X == o.currentX)
	 * 			if(The segments are the same. Id or just overlapping + belonging?) return 0
	 * 			else if(this to left of o) return -1
	 * 			else if(this to right of o) return 1
	 * 			else do some trace
	 * 
	 * 
	 * 		2. Searching for a segment - same as above
	 * 
	 * 		3. Deleting a segment - same as above
	 * 			NB! A segment gets deleted due to a lower eventpoint is encountered or an intersection is handled. 
	 * 			
	 * 		Problems with current_X
	 * 			1. Using doubles in calculations might lead to rounding errors and misses. Should probably use linear algebra here. Compare one current x with an entire edge.
	 * 			2. The best way would be to use the current x only in the segment that is input to the tree, not in the segments that lies within the tree. This way we avoid having to update the entire tree.
	 * 			
	 * 			Example:
	 * 				1. Adding a new segment:
	 * 					newSeg.updateX-coord();
	 * 					status.add(newSeg); <----------Compare to now compares like this: in an edge e: if(this isToRightOf(newSeg.current_X())) return -1. Easier to find a segment then too!
	 * 	
	 * 		
	 * 		
	 * 
	 * 
	 * 
	 * Case 1: x1 < x2 -> return -1
	 * 		Case 2: x1 > x2 -> return 1
	 * 		Case 3: x1 == x2
	 * 					3.1 if they are uppers to many
	 * 					or intersection -> compare their lowers and return -1, 0 or 1
	 * 					3.2 else if they are lower point 
	 * 							-> This should not happen because all edges should have been erased before
	 * 							-> p might be a lower and an upper but this is an else if, meaning that the upper-if above will take it instead
	 * 
	 * 
	 * 		All cases ()
	 * 				- uppers to many
	 * 				- upper to many and an intersection
	 * 				- upper to one and an intersection
	 * 				- etc... skip these for now
	 * 
	 *  NB! current_X of this edge and the one we compare to need to be updated before comparing.
	 *  How to avoid unnecessary updates?
	 */				
	@Override
	public int compareTo(Edge o) {
		//1. Compare o.current_X to this.segment
		//if(o.x is to left) return -1
		//if(o.x is to right) return 1
		//if(o.x is on the line)
			//if(same element (parallell)) (check endpoints, ids, belonings, whatever) return 0
			//else(we have a case where two segments intersect but are not the same. Might be of different lengths.) return -1 as default and print a trace_info
		if(compareCurrentXToEdge(o.current_X, o.sweep_Y) < 1) return -1;
		else if(compareCurrentXToEdge(o.current_X, o.sweep_Y) > 1) return 1;
		else
		{
			/*The point is on the line.
			/We have the following cases:
			
			*/
			
			
			if((lower.compareTo(o.lower) == 0) && (upper.compareTo(o.getUpper()) == 0))// && (upper.getBelonging() == o.upper.getBelonging())) //Need more checks? Id?`IDs must then follow along each segments wherever they may reside.
			{
				//The segments are the same
				return 0;
			}
			
			else if(compareCurrentXToEdge(o.getLower().getX(), o.getLower().getRealY()) < 0) return -1;
		}
	}
	
	/**
	 * Created 2017-06-03
	 * Purpose: Compare a point to a segment to see which side it lies on
	 * Needs: unit test
	 * @param p
	 * @return
	 */
	private int compareCurrentXToEdge(int p_x, int p_y) { //Risk with current x: it has to be calculated using doubles and then cast to int. Might miss intersections... but, intersections might already be caught??
		int x1 = upper.getX();
		int y1 = upper.getRealY();
		
		int x2 = lower.getX();
		int y2 = lower.getRealY();
		
		double d = (p_x - x1) * (y2 - y1) - (p_y - y1) * (x2 - x1);
		
		if(d < 0) return -1;
		else if(d > 0) return 1;
		else return 0;		
	}
	
	
	
	/* Metod för att jämföra ett eftersökt segment med ett befintligt i en nod.
	 * This är eftersökta segmentet
	 * @params: segment är befintliga segmentet i noden
	 * @params: sweep_y är det y-värde sveplinjen har då metoden kallas
	 * @output: 
	 * -1 om this ligger till vänster
	 * 0 om samma
	 * 1 om this ligger till höger
	 * 
	 * Denna kanske endast ska kolla x-värde mot varandra
	 */
	public int newCompareTo(Edge segment, int sweep_y){
		//Beräkna x-värdet hos this för current y.
		
		/*
		int x = currentXCoord(sweep_y);
		Endpoint temp = new Endpoint(x, sweep_y);
		if(temp.isToRightOrLeftOf(segment) < 0){
			return -1;
		}
		else if(temp.isToRightOrLeftOf(segment)>0){
			return 1;
		}
		else return 0;*/
		//Kolla med typ isToLeftOrRight med currentX som argument.
		//Testa currentX-metoden och ta reda på varför den returnerar fel.
		
		double x1 = currentXCoord(sweep_y);
		//System.out.println("Current x coord for ("+this.getUpper().getX()+", "+this.getUpper().getRealY()+"), ("+this.getLower().getX()+", "+this.getLower().getRealY()+") is "+x1);
		
		double x2 = segment.currentXCoord(sweep_y);
		//System.out.println("Current x coord for ("+segment.getUpper().getX()+", "+segment.getUpper().getRealY()+"), ("+segment.getLower().getX()+", "+segment.getLower().getRealY()+") is "+x2);
		if(x1>x2) return 1;
		else if(x2>x1) return -1;
		//else if(x1 == x2){
			
			
			//Ovan metod borde inte funka! Måste lägga till att de kan överlappa varandra. Kolla då deras lower med en determinantmetod?
		//}
		else return 0;
		
		
	}
	
	
	/*Används ej mer.
	 * Returnerar 	-1 om denna edge pekar åt vänster i förhållande till Edge e.
	 * 				+1 om denna edge pekar åt höger
	 * 				0 om de är samma
	 */
	public int specialCompareTo(Edge e, int sweep_y){
		if(currentXCoord(sweep_y) < e.currentXCoord(sweep_y) || currentXCoord(sweep_y) == e.currentXCoord(sweep_y) && compareSides(sweep_y-1, e)==-1){//Check om detta redan är en lower???
			//Kolla riktning direkt under sweepline!!! Hur görs deta bäst?
			//Använd upper och lower som line. Kolla vilken sida this.lower ligger på. typ.
			return -1;
		}
		else if(currentXCoord(sweep_y)>e.currentXCoord(sweep_y) || currentXCoord(sweep_y)==e.currentXCoord(sweep_y) && compareSides(sweep_y-1, e)==1){
			return 1;
		}
		else if(currentXCoord(sweep_y)==e.currentXCoord(sweep_y)&&compareSides(sweep_y, e)==0){//Problematiskt att använda lower här. Blir fel vid korsade linjer.
			return 0;
		}
		System.out.println("Lacking if-statement in specialCompareTo in Edge.");
		return 0;
	}
	
	//Används bara då två segment har punkter i samma x-coord
	//Nu beräknar denna vilka om ett segment ligger till vänster om ett annat precis under sveplinjen
	public int compareSides(int sweep_y, Edge e){//Tidigare tog denna en endpoint som var e.getLower()
		double x1 = currentXCoord(sweep_y);
		double x2 = e.currentXCoord(sweep_y);
		
		
		//Fullösning. Kan funka eftersom inget segment som har lowerpoint i nuvarande p ska sökas igenom. Förhoppningsvis redan borttaget.
		if(x1==x2){
			return 0;
		}
		else if(x1 < x2){
			return -1;
		}
		
		else if(x1>x2){
			return 1;
		}
		
		//Determinant stuff
		/*int det = (lower.getX()-upper.getX())*(p.getRealY()-upper.getRealY()) - (lower.getRealY()-upper.getRealY())*(p.getX()-upper.getX());
		if(det<0){
			return 1;
		}
		else if(det>0){
			return -1;
		}
		
		return 0;*/
		System.out.println("Compare sides i Edge returnerar fel.");
		return 0;
	}
	
	//Ändra i search: Om current x är lika men uppers och lowers inte är det. Då har vi detta specialfall!
	//Denna används för att avgöra vilken sida av ett annat segment ett segment ska sättas in i i statusen.
		public int isToRightOrLeftOf(Edge segment){
			//Determinant stuff
			int det1 = (segment.getLower().getX()-segment.getUpper().getX())*(getUpper().getRealY()-segment.getUpper().getRealY()) - (segment.getLower().getRealY()-segment.getUpper().getRealY())*(getUpper().getX()-segment.getUpper().getX());
			int det2 = (segment.getLower().getX()-segment.getUpper().getX())*(getLower().getRealY()-segment.getUpper().getRealY()) - (segment.getLower().getRealY()-segment.getUpper().getRealY())*(getLower().getX()-segment.getUpper().getX());
			if(det1<0 || det1==0 && det2<0){//Be careful with the grouping here. This mght be wrong.
				return -1;
			}
			else if(det1>0 || det1 == 0 && det2>0){//Kolla både upper och lower om upper skulle vara samma för båda
				return 1;
			}
					
			else return 0;//They are on a line(Might not work if there is to different segments on a line.)
		}
		
		
		//Denna metod funkade 27/1
		//Returnerar null om intersection ligger utanför segmentens endpoints
		//Testa med vertikala och horisontella linjer
		public Endpoint isCrossingWith(Edge segment){
			System.out.println("Inne i metoden.");
			if(upper.getX()!=lower.getX() && segment.getUpper().getX()!=segment.getLower().getX()){//Avoid division by zero. Test this case!
				
				System.out.println("Linjerna lutar!");//Fail!!! Det gör de inte alls! Behöver ett test mot horisontell linje
				
				double k1 = (upper.getRealY()-lower.getRealY())/(upper.getX()-lower.getX());
				double k2 = (segment.getUpper().getRealY()-segment.getLower().getRealY())/(segment.getUpper().getX()-segment.getLower().getX());
				
				double m1 = upper.getRealY()-(k1*upper.getX());//Använd kända värden på x och y.
				double m2 = segment.getUpper().getRealY()-(k2*segment.getUpper().getX());//Använd kända värden på x och y.
				
				double x = (m1-m2)/(k2-k1);//Correct? Om det är en intersection. Oops. Division med 0 här om det är parallella linjer! Fixit!
				double y1 = k1*x+m1;
				double y2 = k2*x+m2;
				
				//Hittar inte intersection då ena linjen är horisontell
				if(y1==y2 && y1<upper.getRealY() && y1>lower.getRealY() && y1<segment.getUpper().getRealY() && y1>segment.getLower().getRealY()){
					System.out.println("The method is working. We have an intersection at:" + x +", "+ y1);
					Endpoint intersection = new Endpoint((int)x, (int)y1);
					System.out.println("Hej och hå!");
					return intersection;
				}
				else{
					System.out.println("Går den in i else?");
					
				}
			}
			else System.out.println("Division by zero in method isCrossingWith() in Edge."); return null;
		}
		
		
		 /**
		0002   * Computes the intersection between two segments. 
		0003   * @param x1 Starting point of Segment 1
		0004   * @param y1 Starting point of Segment 1
		0005   * @param x2 Ending point of Segment 1
		0006   * @param y2 Ending point of Segment 1
		0007   * @param x3 Starting point of Segment 2
		0008   * @param y3 Starting point of Segment 2
		0009   * @param x4 Ending point of Segment 2
		0010   * @param y4 Ending point of Segment 2
		0011   * @return Point where the segments intersect, or null if they don't
		0012   */
		
		
		//http://www.ahristov.com/tutorial/geometry-games/intersection-segments.html
		//This method is for spotting an intersection between two segments. This intersection
		//shall later be inserted as a new eventPoint in the queue
		
		//2016-04-06: This seems to be in use but not handling vertical segments like it should.
		//Test performed:
		public Endpoint doIntersect(Edge segment) {
				    int x1 = upper.getX();
				    //int y1 = upper.getRealY();
				    int y1 = upper.getY();//Måste använda getY() och inte realY() här.
				    int x2 = lower.getX();
				    //int y2 = lower.getRealY();
				    int y2 = lower.getY();
				    
				    int x3 = segment.getUpper().getX();
				    //int y3 = segment.getUpper().getRealY();
				    int y3 = segment.getUpper().getY();
				    int x4 = segment.getLower().getX();
				    //int y4 = segment.getLower().getRealY();
				    int y4 = segment.getLower().getY();
			
			
					int d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4); //Denominator determinant for point calculation
				    if (d == 0) return null;//Lines are parallell
				    
				    //Point calculation
				    int xi = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;
				    int yi = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;
				    
				  //Added 2016-04-06: Check if any of the lines are vertical
			        if(x1 == x2 || x3 == x4){
			            //2016-04-06: Check if the intersection point lies outside any of the segment in the y direction
			            if(yi < Math.min(y1, y2) || yi > Math.max(y1, y2)) return null;
			            if(yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) return null;
			        }
				    
				    //Check if intersection lies outside the segments endpoints
				    Endpoint p = new Endpoint(xi,yi);
				    if (xi < Math.min(x1,x2) || xi > Math.max(x1,x2)) return null;
				    if (xi < Math.min(x3,x4) || xi > Math.max(x3,x4)) return null;
				    return p;
				  }
		
		
		//http://www.ahristov.com/tutorial/geometry-games/intersection-segments.html
		//This method is for spotting an intersection between two segments. This intersection
		//shall later be inserted as a new eventPoint in the queue
		public Endpoint intersectionOf(int x1,int y1,int x2,int y2, int x3, int y3, int x4,int y4) {
			int d = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4); //Denominator determinant for point calculation
			if (d == 0) return null;//Lines are parallell

			//Point calculation
			int xi = ((x3-x4)*(x1*y2-y1*x2)-(x1-x2)*(x3*y4-y3*x4))/d;
			int yi = ((y3-y4)*(x1*y2-y1*x2)-(y1-y2)*(x3*y4-y3*x4))/d;

			//Check if intersection lies outside the segments endpoints
			Endpoint p = new Endpoint(xi,yi);
			if (xi < Math.min(x1,x2) || xi > Math.max(x1,x2)) return null;
			if (xi < Math.min(x3,x4) || xi > Math.max(x3,x4)) return null;
			return p;
		}
		
		

}
