package algorithm;

import java.awt.Color;
import java.awt.Graphics;
import java.io.Serializable;
import java.util.ArrayList;

public class Endpoint implements Comparable<Endpoint>, Serializable{

	private int x, y;
	private int realY;
	public boolean isUpper, isLower= false;
	public boolean isIntersection = false; 
	private Edge segment = null;
	private ArrayList<Edge> intersectingEdges = null;
	public static final int NONE = 0, POLYGON1 = 1, POLYGON2 = 2;
	private int belongsTo;

	private Edge nextSegment = null;
	private Edge previousSegment = null;
	public ArrayList<Edge> isUpperTo;
	public ArrayList<Edge> isLowerTo;
	
	public Edge leftmost, rightmost = null;

	/**
	 * Constructor
	 * @param x
	 * @param y
	 */
	public Endpoint(int x, int y){
		this.x = x;
		this.y = y;
		realY = 400-y;
		isLowerTo = new ArrayList<Edge>();
		isUpperTo = new ArrayList<Edge>();
	}

	public void addUpperTo(Edge segment){
		isUpperTo.add(segment);
	}

	public void addLowerTo(Edge segment){
		isLowerTo.add(segment);
	}

	public ArrayList<Edge> getUpperTo(){
		return isUpperTo;
	}

	public ArrayList<Edge > getLowerTo(){
		return isLowerTo;
	}
	
	public void clearSegmentsInUpperTo(){
		isUpperTo.clear();
	}




	public int getX(){
		return x;
	}

	public int getY(){
		return y;
	}

	public int getRealY(){
		return 400-y;
	}

	public void setNextSeg(Edge segment){
		nextSegment = segment;
	}

	public void setPrevSeg(Edge segment){
		previousSegment = segment;
	}

	public Edge getNextSeg(){
		return nextSegment;
	}

	public Edge getPrevSeg(){
		return previousSegment;
	}

	public void paintPoint(Graphics g){
		g.fillRect(x, y, 3, 3);
	}

	public void setUpper(){
		isUpper = true;
		isLower = false;
	}

	public void setLower(){
		isLower = true;
		isUpper = false;

	}

	public boolean isUpper(){
		return isUpper;
	}
	public boolean isLower(){
		return isLower;
	}

	public void setCoords(int x, int y){
		this.x = x;
		this.y = y;
	}

	public Edge getSegment(){
		return segment;
	}

	public void setSegment(Edge segment){
		this.segment = segment;
	}

	public ArrayList<Edge> getIntersectingEdges(){
		return intersectingEdges;
	}

	public void setIntersectingEdges(ArrayList<Edge> edges){
		intersectingEdges = edges;
	}


	public boolean isSmallerThan(Endpoint e){
		//Case 1: Check if this point is smaller than e in y or greater in x.
		if(y < e.getY() || y == e.getY() && x >e.getX()){
			return true;
		}
		//Case 2: Check if they lie on the same point
		if(y == e.getY()&&x == e.getX()){
			//Case 2.1: Prioritize upper before lower. Otherwhise lower may be deleted from status before tested for intersection with upper.
			if(this.isLower && e.isUpper){
				return true;
			}
			else if(this.isUpper&&e.isLower){
				return false;
			}

			//Case 2.2: If both are upper and lie on the same point. Sort after their lower endpoints.
			else if(this.isUpper&&!e.isUpper){//If the points are totally equal. Compare their segments lower endpoints
				if(this.segment.getLower().getY()<e.getSegment().getLower().getY()){//Någonstans checkas x-värdet på lower men y är viktigare. Även i statusen?
					return true;
				}
				else if(this.segment.getLower().getY() == e.getSegment().getLower().getY() && this.segment.getLower().getX()>e.getSegment().getLower().getX()){
					return true;
				}
			}
		}
		return false;
	}



	/*private boolean segmentDuplicate(Edge segment1, Edge segment2){

		//Check if the edges are the same if they have the same upper and lower.
		if(segment1.getUpper().getX()==segment2.getUpper().getX()&&segment1.getUpper().getY()==segment2.getUpper().getY()&&segment1.getLower().getX()==segment2.getLower().getX()&&segment1.getLower().getY()==segment2.getLower().getY()){
			return true;
		}
		//Check if the edges are the same if they have the different upper and lower.(Total overlap but different directions)
		//Must compare only the coordinates and not the whole segments
		else if(segment1.getUpper().getX()==segment2.getLower().getX()&&segment1.getUpper().getY()==segment2.getLower().getY()&&segment1.getLower().getX()==segment2.getUpper().getX()&&segment1.getLower().getY()==segment2.getUpper().getY()){
			return true;
		}
		return false;
	}*/

	public boolean isIntersection(){
		return isIntersection;
	}

	public void setIntersection(boolean set){
		isIntersection = set;
	}

	public void setBelonging(int polygon){
		if(polygon == 0 || polygon == 1 || polygon == 2){
			belongsTo = polygon;
		}
	}

	public int getBelonging(){
		return belongsTo;
	}

	/**
	 * Compare this endpoint to another endpoint in Y and X
	 * Returns:
	 * 	-1 if this point has lower Y and/or X coordinate than Endpoint o
	 */
	@Override
	public int compareTo(Endpoint o) {
		// TODO Auto-generated method stub
		if(realY<o.getRealY() || realY==o.getRealY() && x>o.getX()){//This is smaller than o
			return -1;
		}
		else if(realY==o.getRealY()&&x==o.getX()){//Equals
			return 0;
		}
		else return 1;
	}
	
	

	public boolean isEqualTo(Endpoint p) {
		if(x == p.getX() && y == p.getY()) return true;
		return false;
	}
	
	public boolean upperToArrayContains(Edge segment)
	{
		for(Edge e : isUpperTo)
		{
			if(segment.id == e.id)
			{
				return true;
			}
		}
		return false;
	}
	
	public boolean lowerToArrayContains(Edge segment)
	{
		for(Edge e : isLowerTo)
		{
			if(segment.id == e.id)
			{
				return true;
			}
		}
		return false;
	}

	
	/**
	 * For finding out which side of a segment point lies
	 * Returns: 
	 * 	-1 for leftside
	 *  0 for on the line
	 *  1 for right side
	 */
	public int isToRightOrLeftOf(Edge segment){

		int det = (segment.getLower().getX()-segment.getUpper().getX())*(getRealY()-segment.getUpper().getRealY()) - (segment.getLower().getRealY()-segment.getUpper().getRealY())*(getX()-segment.getUpper().getX());
		if(det<0){
			return -1;
		}
		else if(det>0){
			return 1;
		}

		return 0;
	}


	
	/**
	 *  Find the leftmost segment that has this Enpoint as an upper point.
	 */
	public Edge findLeftmost(){
		Edge left = isUpperTo.get(0);
		for(Edge e : isUpperTo){
			if(e.getLower().isToRightOrLeftOf(left)<0){
				left = e;
			}
		}
		leftmost = left;
		return left;
	}

	/**
	 *  Find the rightmost segment that has this Enpoint as an upper point.
	 */
	public Edge findRightmost(){
		Edge right = isUpperTo.get(0);
		for(Edge e : isUpperTo){
			if(e.getLower().isToRightOrLeftOf(right)>0){
				right = e;
			}
		}
		rightmost = right;
		return right;
	}


}
